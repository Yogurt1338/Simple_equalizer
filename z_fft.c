#include "z_fft.h"
#include "z_math.h"

// Функция для вычисления FFT
int fft(TYPE_FFT *x, uint32_t N)
{
    int i, j, l;
    uint32_t M = floor_log2_32(N);

    // Обратная сортировка битов
    for (i = 0; i < N; i++) {
        j = reverse_bits(i, M);
        if (i < j) {
            float tR = x[j].real;
            float tI = x[j].imag;
            x[j].real = x[i].real;
            x[j].imag = x[i].imag;
            x[i].real = tR;
            x[i].imag = tI;
        }
    }

    // Основные циклы
    for (l = 1; l <= M; l++) {   // Цикл по log2(N)
        int le  = (1 << l);      // Длина подцепи
        int le2 = (le >> 1);     // Половина длины подцепи

        float sR = cos(PI / le2);
        float sI = -sin(PI / le2);

        // Вызов функции butterfly
        butterfly(x, le, le2, sR, sI, N);
    }

    return 0;
}

// Функция для вычисления FFT для действительных чисел
int fft_real(TYPE_FFT *x, uint32_t N)
{
    int i, j, k, l;
    uint32_t M = N >> 1;
    uint32_t ND4 = N >> 2;

    // Разделение четных и нечетных частей
    for (i = 0; i < M; i++) {
        x[i].real = x[i << 1].real;
        x[i].imag = x[(i << 1) + 1].real;
    }

    // FFT для N/2 точек
    fft(x, M); 

    // Декомпозиция частотной области четных и нечетных
    for (i = 1; i < ND4; i++) {
        j = M - i;          // Определение индекса для нечетного отражения
        k = i + M;          // Индекс для смещения четных частей
        l = j + M;          // Индекс для смещения нечетных частей

        // Вычисление новых значений для четных и нечетных частей
        x[k].real = (x[i].imag + x[j].imag) / 2;        // Четная часть - среднее значение между двумя нечетными
        x[l].real = x[k].real;                          // Зеркальное отображение для нечетной части
        x[k].imag = -(x[i].real - x[j].real) / 2;       // Мнимая часть четной части - половина разности двух действительных
        x[l].imag = -x[k].imag;                         // Зеркальное отображение для мнимой части нечетной части
        x[i].real = (x[i].real + x[j].real) / 2;        // Действительная часть нечетной части - среднее значение между двумя четными
        x[j].real = x[i].real;                          // Зеркальное отображение для действительной части четной части
        x[i].imag = (x[i].imag - x[j].imag) / 2;        // Мнимая часть нечетной части - половина разности двух мнимых
        x[j].imag = -x[i].imag;                         // Зеркальное отображение для мнимой части четной части
    }

    // Присвоение нулей для ненужных значений
    x[N - ND4].real = x[ND4].imag;              // Присвоение мнимой части значения, соответствующего четной части
    x[M].real = x[0].imag;                      // Присвоение действительной части четной части значения, соответствующего мнимой
    // Обнуление мнимой части, которая не нужна
    x[N - ND4].imag = 0;
    x[M].imag = 0;                 
    x[ND4].imag = 0;               
    x[0].imag = 0;                 


    // Завершение последней стадии FFT
    float sR = cos(PI / M);
    float sI = -sin(PI / M);

    // Вызов функции butterfly для завершения последней стадии FFT
    butterfly(x, M * 2, M, sR, sI, N);

    return 0;
}

// Функция для вычисления обратного FFT
int ifft(TYPE_FFT *x, uint32_t N)
{
    int k;

    // Инверсия мнимой части
    for (k = 0; k < N; k++) {
        x[k].imag = -x[k].imag;
    }

    // Использование FFT
    fft(x, N);

    // Масштабирование результатов
    for (k = 0; k < N; k++) {
        x[k].real /= N;
        x[k].imag = -x[k].imag / N;
    }

    return 0;
}

// Функция для вычисления обратного FFT для действительных чисел
int ifft_real(TYPE_FFT *x, uint32_t N)
{
    int k;

    // Симметризация частотной области
    for (k = (N >> 1) + 1; k < N; k++) {
        x[k].real = x[N - k].real;
        x[k].imag = -x[N - k].imag;
    }

    // Сложение действительной и мнимой частей
    for (k = 0; k < N; k++) {
        x[k].real += x[k].imag;
    }

    // Использование FFT
    fft_real(x, N);

    // Масштабирование результатов
    for (k = 0; k < N; k++) {
        x[k].real = (x[k].real + x[k].imag) / N;
        x[k].imag = 0;
    }

    return 0;
}